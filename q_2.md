# Вопрос 2
## Что следует оставлять в основном теле определения класса и что разумно выносить из него? Приведите убедительный пример.
___

В данном вопросе рассматриваются только методы класса, так как поля класса мы не можем определить за его границами.
Для примера буду работать с классом `Date`.

```cpp
class Date {
private:
    int y, m, d;
public:
    Date(int y, int m, int d);
    void add_day(int n);
    int month();
}

Date::Date(int yy, int mm, int dd) 
    :y{yy}, m{mm}, d{dd}

void Date::add_day(int n) {
    // определяем
}

int month () {return m;} // ошибка: не указали Date::
```

Определяя методы за пределами класса, мы должны с помощью `::` оператора разрешения области видимости указать, к какому класcу они принадлежат. Для этого используется обозначение *имя_класса* :: *имя_члена*.

**Примечание.** Запись *:y{yy}, m{mm}, d{dd}* представляет собой инициализацию членов класа и называется списком инициализации (членов). 

Метод класса можно также определить прямо в определении класса.
```cpp
class Date {
private:
    int y, m, d;
public:
    Date(int y, int m, int d) {:y{yy}, m{mm}, d{dd}};
    void add_day(int n) {...};
    int month(return m);
}
```

Сразу же отметим, что теперь объявление класса стало больше и запутаннее. В данном примере код конструктора и метода `add_day()` могут содержать десятки строк. Это в несколько раз увеличивает размер обяъвления класса и затрудняет поиск интерфейса среди деталей реализации. Поэтому мы не рекомендуем определять большие функции в объявлении класса. Соответсвенно определения коротких и простых функций можно размещать в объявлении класса. 

Определение метода в классе приводит к следующим последствиям:
1. Метод становится встраиваемым (_inline_), т.е. компилятор будет пытаться вместо вызова метода генерировать его код. Это может дать значительное преимущество в производительности для часто вызываемых методов, таких как `month()`. 

[//]: <> (1. Если класс экспортируется из других модулей, то методы из него уже не будут встроенными. С оптимизацией все очень сомнительно. [Статья - https://habr.com/ru/company/otus/blog/561772/. "Сегодня `inline` - это про one definition rule, а не про inline expansion оптимизацию." ) 

2. При изменении тела встраиваемого метода придется перекомпилировать заново все модули, в которых он используется. Если тело метода определено за пределами объявления класса, то потребуется перекомплировать только само определение класса. Отсутствие необходимости повторной компиляции при изменении тела функции может оказаться важным преимуществом в больших программах.

3. Определение класса становится больше по размеру. Следавательно, будет сложнее находить требуемые члены среди определений методов. То есть приводит к нечитабельности кода.

Очевидное правило глассит: не размещайте тела методов в объявлении класса, если вам не нужна повышенная эффективность программы за счет использования небольших встраиваемых методов. Большие методы, состоящие из пяти и более строк, ничего не выиграют от подстановки. Не сладует делать встраиваемыми метода, содержащие более одного-двух выражений.


[//]: <> (Рекомендация 36 из https://habr.com/ru/post/172091/. Т.е. в в модуле .h определения класса лучше держать только объявления методов, а их реализации в другом .cpp модуле)


P. S. В данном вопросе я использовала "метод" вместо "функции-члена", поскольку чаще используют это слово.

P. S. S. Вопрос - кринж. Будь я экзаменатором убрала бы его, тем более, что на практиках мы вроде нечасто (либо совсем) не использовали объявление методов вне класса. Как по мне, это абсолютно не делает код читабельнее, а только вносит неразбериху, но ответ сделан со ссылкой на Страуструпа. 
