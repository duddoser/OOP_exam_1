# Вопрос 7
## Понятие интерфейса класса: что нежелательно туда выносить? Почему?	

Интерфейсным классом называется класс, не имеющий данных и состоящий в основном из чисто виртуальных функций. Такое решение позволяет полностью отделить реализацию от интерфейса — клиент использует интерфейсный класс, — в другом месте создается производный класс, в котором переопределяются чисто виртуальные функции и определяется функция-фабрика. Детали реализации полностью скрыты от клиента. Таким образом реализуется истинная инкапсуляция, невозможная при использовании обычного класса. 

**Пример**
```cpp
class IErrorLog {
public:
    virtual bool openLog(const char *filename) = 0;
    virtual bool closeLog() = 0;

    virtual bool writeError(const char *errorMessage) = 0;

    virtual ~IErrorLog() {}; // создаем виртуальный деструктор, чтобы вызывался соответствующий деструктор дочернего класса в случае, если удалим указатель на IErrorLog
};

class FileErrorLog : public IErrorLog {
public:
    virtual bool openLog(const char *filename) {
        cout << "Writting in file: " << filename << endl;
    }

    virtual bool closeLog() {
        cout << "Closing Log" << endl;
    }

    virtual bool writeError(const char *errorMessage) {
        cout << "Current error: " << errorMessage << endl;
    }

    virtual ~FileErrorLog() {cout << "FileErrorLog destructor" << endl;}
};
```
Любой класс, который наследует IErrorLog, должен предоставить свою реализацию всех 3 методов класса IErrorLog.
В интерфейс нежелательно выносить функции, которые мы не будем переопределять. Это не имеет смысла: в интерфейсе определены общие методы для группы классов, соответственно уникальные для каждого класса методы нет необходимости определять в интерфейсе. Но это чисто мой ответ, я не понимаю, что хочет услышать Петрусевич.
